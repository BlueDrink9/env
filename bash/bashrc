# vim:ft=sh:tw=78:ts=4
# vim:foldmethod=marker:foldmarker={[},{]}
# Contains bash and cli bootstrapping code

# XXX For debugging, call $(bash_debug_log) with optional logfile param
# to show all bash commands run. Default logfile is ${HOME}/.debug_log_bashsetx.
# (More plusses mean different file/function)

# # If not running interactively, don't do anything
# case $- in
#     *i*) ;;
#       *) return;;
# esac

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
export DOTFILES_DIR=$(cd "${SCRIPT_DIR}/.." && pwd)


if [ -z $HOMEBREW_PREFIX ]; then
    if [[ "$OSTYPE" =~ "darwin1" ]]; then  # OSX specific stuff
        export HOMEBREW_PREFIX="$HOME/homebrew"
    elif [ "$OSTYPE" = "linux-gnu" ]; then  # Linux specific stuff
        # Linuxbrew paths
        export HOMEBREW_PREFIX="$HOME/.linuxbrew"
    fi
    brewbash="$HOMEBREW_PREFIX/bin/bash"
    # If available, replace bash with brew version. (More up-to-date than system.)
    # Only if running interactively.
    if [ -f $brewbash ] && [ "$BASH" != "$brewbash" ] && \
        [ -z $HAVE_LOADED_BASH ] && [[ $- == *i* ]]; then
        export HAVE_LOADED_BASH=1
        # Exec replaces the shell with the specified process.
        exec $HOMEBREW_PREFIX/bin/bash -l
    fi
fi

# Reload/source inputrc
# bind -f ${SCRIPT_DIR}/inputrc.sh
INPUTRC="${SCRIPT_DIR}/inputrc.sh"
source ${SCRIPT_DIR}/functions.sh
source ${SCRIPT_DIR}/settings.sh
BASH_ENV="${SCRIPT_DIR}/aliases.sh" # Aliases are used for all readline apps.
source ${SCRIPT_DIR}/aliases.sh
source ${SCRIPT_DIR}/prompt.sh

# Unset include guards to allow refreshing
unset BASH_FUNCTIONS_LOADED SCRIPT_FUNCTIONS_LOADED

# test if this is an ssh shell
if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
    export SESSION_TYPE=remote/ssh
    export SSHSESSION=1
    # many other tests omitted
else
    case $(ps -o comm= -p $PPID) in
        sshd|*/sshd) SESSION_TYPE=remote/ssh;;
    esac
fi

#{[} tmux
# Run tmux on ssh connect
# Check if interactive is part of shell options (running interactively)
case $- in
    *i*)
        if substrInStr "256" "$TERM" ; then
            TMUX_256_arg="-2"
        else
            TMUX_256_arg=""
        fi
        if [ -z "$TMUX_ALLOW_DETACH" ]; then
            execCmd="exec"
            # Else nothing
        fi
        if command -v tmux>/dev/null; then
            if [[ ! $TERM =~ screen ]] && [[ -z $TMUX ]]; then
                # PNAME="$(ps -o comm= $PPID)";
                # useTmuxFor="login sshd gnome-terminal init wslbridge-backe"
                # useTmuxFor="sshd"
                # if contains "$useTmuxFor" "$PNAME"; then
                if [ "$SSHSESSION" ] || [ -z "$DISPLAY" ]; then
                    if tmux ls 2> /dev/null | grep -q -v attached; then
                        $execCmd tmux $TMUX_256_arg attach -t $(tmux ls 2> /dev/null | grep -v attached | head -1 | cut -d : -f 1)
                    else
                        $execCmd tmux $TMUX_256_arg
                    fi
                fi
            fi
        fi
        ;;
esac
# {]} tmux

# Register keys
if [ -z "$SSH_AUTH_SOCK" ]; then
    # Decay after 120 mins
    eval $(ssh-agent -t 120m) > /dev/null # 2>&1
    lastpass_ssh_key_add
fi

# Virtual console
if [ "$TERM" = "Linux" ]; then
    source "${DOTFILES_DIR}/terminal/virtual_console/reuse_X_colors.sh" "${DOTFILES_DIR}/terminal/x/solarized_light"
fei


# {[] fzf
if [ -f ~/.fzf.bash ]; then
    source ~/.fzf.bash
    export FZF_CTRL_R_OPTS='--sort'
    # Disable alt-c mapping to allow ;q to keep working.
    # Nah, just change ;q binding to ddi instead of cc
    # bind '"c":"c"
fi
# {]] fzf
