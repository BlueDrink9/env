# vim:ft=sh:tw=78:ts=4
# vim:foldmethod=marker:foldmarker={[},{]}
# Contains bash and cli bootstrapping/init code

# XXX For debugging, call $(bash_debug_log) with optional logfile param
# to show all bash commands run. Default logfile is ${HOME}/.debug_log_bashsetx.
# (More plusses mean different file/function)

# # If not running interactively, don't do anything
# case $- in
#     *i*) ;;
#       *) return;;
# esac

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
export DOTFILES_DIR=$(cd "${SCRIPT_DIR}/.." && pwd)

if [ -z "$HOMEBREW_PREFIX" ]; then
    if [[ "$OSTYPE" =~ "darwin1" ]]; then  # OSX specific stuff
        export HOMEBREW_PREFIX="$HOME/homebrew"
    elif [ "$OSTYPE" = "linux-gnu" ]; then  # Linux specific stuff
        # Linuxbrew paths
        export HOMEBREW_PREFIX="$HOME/.linuxbrew"
    fi
fi
# If available, replace bash with brew version. (More up-to-date than system.)
# Only if running interactively.
case $- in
    *i*)
        if [ -n "$BASH" ]; then
            if [ -n "$HOMEBREW_PREFIX" ]; then
                brewbash="$HOMEBREW_PREFIX/bin/bash"
            fi
            if [ -f "$brewbash" ] && [ "$BASH" != "$brewbash" ] && \
                [ -z "$HAVE_LOADED_BASH" ]; then
            export HAVE_LOADED_BASH=1
            # Exec replaces the shell with the specified process.
            exec "$HOMEBREW_PREFIX/bin/bash" -l
        fi
    fi
esac

# Reload/source inputrc
# bind -f "${SCRIPT_DIR}/inputrc.sh"
INPUTRC="${SCRIPT_DIR}/inputrc.sh"
source "${SCRIPT_DIR}/functions.sh"
source "${SCRIPT_DIR}/settings.sh"
BASH_ENV="${SCRIPT_DIR}/aliases.sh" # Aliases are used for all readline apps.
source "${SCRIPT_DIR}/aliases.sh"
source "${SCRIPT_DIR}/prompt.sh"

# Unset include guards to allow refreshing
unset BASH_FUNCTIONS_LOADED SCRIPT_FUNCTIONS_LOADED

# Virtual console
if [ "$TERM" = "linux" ]; then
    # source "${DOTFILES_DIR}/terminal/virtual_console/reuse_X_colors.sh" "${DOTFILES_DIR}/terminal/x/solarized_light"
    source "${DOTFILES_DIR}/terminal/virtual_console/solarized.sh"
fi

# test if this is an ssh shell
if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
    export SESSION_TYPE=remote/ssh
    export SSHSESSION=1
    # many other tests omitted
else
    case $(ps -o comm= -p $PPID) in
        sshd|*/sshd) SESSION_TYPE=remote/ssh;;
    esac
fi

# Check if interactive is part of shell options (running interactively)
case $- in
    *i*)
        #{[} tmux
        # Run tmux on ssh connect
        if substrInStr "256" "$TERM" ; then
            TMUX_256_arg="-2"
        else
            TMUX_256_arg=""
        fi
        if [ -z "$TMUX_ALLOW_DETACH" ]; then
            execCmd="exec"
            # Else nothing
        fi
        if command -v tmux>/dev/null; then
            if [[ ! $TERM =~ screen ]] && [[ -z $TMUX ]]; then
                # PNAME="$(ps -o comm= $PPID)";
                # useTmuxFor="login sshd gnome-terminal init wslbridge-backe"
                # useTmuxFor="sshd"
                # if contains "$useTmuxFor" "$PNAME"; then
                if [ -z "$NOTMUX" ] && { [ "$SSHSESSION" ] || [ -z "$DISPLAY" ]; }; then
                    if tmux ls 2> /dev/null | grep -q -v attached; then
                        $execCmd tmux $TMUX_256_arg attach -t $(tmux ls 2> /dev/null | grep -v attached | head -1 | cut -d : -f 1)
                    else
                        $execCmd tmux $TMUX_256_arg
                    fi
                fi
            fi
        fi
        # {]} tmux

        # Register keys
        if [ -z "$SSH_AUTH_SOCK" ]; then
            # Decay after 120 mins
            eval $(ssh-agent -t 120m) > /dev/null # 2>&1
        fi
        lastpass_ssh_key_add

        # {[} fzf
        if [ -f ~/.fzf.bash ]; then
            source ~/.fzf.bash
            export FZF_CTRL_R_OPTS='--sort'
            # Disable alt-c mapping to allow ;q to keep working.
            # Nah, just change ;q binding to ddi instead of cc
            # bind '"c":"c"
        fi
        # {]} fzf
        ;;
    *) return;;
esac
